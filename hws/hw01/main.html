<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-08-17 Mon 17:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Zubair Abid (20171076)" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8f1c036">1. Introduction</a></li>
<li><a href="#orge00648f">2. Recursion on Lists</a>
<ul>
<li><a href="#org6e29c59">2.1. Problem No. 1.1: Repeat</a>
<ul>
<li><a href="#org0c075bd">2.1.1. Solution</a></li>
</ul>
</li>
<li><a href="#org27e5392">2.2. Problem No. 1.2: Invert</a>
<ul>
<li><a href="#org5588fbc">2.2.1. Solution:</a></li>
</ul>
</li>
<li><a href="#orgec3e1d5">2.3. Problem No. 1.3: Count Occurences</a>
<ul>
<li><a href="#org16c39fc">2.3.1. Solution</a></li>
</ul>
</li>
<li><a href="#org0a3785f">2.4. Problem No. 1.4: Product</a>
<ul>
<li><a href="#org970f629">2.4.1. Solution</a></li>
</ul>
</li>
<li><a href="#org90107ee">2.5. Problem No. 1.5: Every</a>
<ul>
<li><a href="#org07325d8">2.5.1. Solution</a></li>
</ul>
</li>
<li><a href="#org2dc6ec8">2.6. Problem No. 1.6: Merge</a>
<ul>
<li><a href="#org947cf58">2.6.1. Solution</a></li>
</ul>
</li>
<li><a href="#org56d7969">2.7. Flatten</a>
<ul>
<li><a href="#orgaa187a3">2.7.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf0eb3bd">3. Recursion on Trees</a>
<ul>
<li><a href="#orge15887c">3.1. Problem No. 2.1: Preorder Traversal</a>
<ul>
<li><a href="#orgdcc5971">3.1.1. Solution</a></li>
</ul>
</li>
<li><a href="#org2841796">3.2. Problem No. 2.2: Inorder</a>
<ul>
<li><a href="#org1386721">3.2.1. Solution</a></li>
</ul>
</li>
<li><a href="#org9477419">3.3. Problem No. 2.3: Postorder</a>
<ul>
<li><a href="#orgc0fe089">3.3.1. Solution</a></li>
</ul>
</li>
<li><a href="#org8f50b82">3.4. Problem No. 2.4: Count All Nodes</a>
<ul>
<li><a href="#orgff1afc2">3.4.1. Solution</a></li>
</ul>
</li>
<li><a href="#org3985fd4">3.5. Problem No. 2.5: Count Leaf Nodes</a>
<ul>
<li><a href="#org8d74b37">3.5.1. Solution</a></li>
</ul>
</li>
<li><a href="#org102199e">3.6. Problem No. 2.6: Count Internal Nodes</a>
<ul>
<li><a href="#orge94fbd5">3.6.1. Solution</a></li>
</ul>
</li>
<li><a href="#orgc1a76b2">3.7. Problem No. 2.7: Map</a>
<ul>
<li><a href="#org6af120e">3.7.1. Solution:</a></li>
</ul>
</li>
<li><a href="#orgf83f438">3.8. Problem No. 2.8: Value at Path</a>
<ul>
<li><a href="#org78dd3c7">3.8.1. Solution</a></li>
</ul>
</li>
<li><a href="#org1fd0791">3.9. Problem No. 2.9: Search</a></li>
<li><a href="#orga926a06">3.10. Problem No. 2.10: Update</a></li>
<li><a href="#orgbd61e5c">3.11. Problem No. 2.11: Insert</a></li>
</ul>
</li>
<li><a href="#org5d9df27">4. Tangle</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8f1c036" class="outline-2">
<h2 id="org8f1c036"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Solution to HW01 of PoPL Monsoon 2020.
</p>

<p>
All of the solutions have been implemented using recursion and avoid using 
any of the following inbuilt functions:
</p>

<ul class="org-ul">
<li><code>map</code></li>
<li><code>andmap</code></li>
<li><code>ormap</code></li>
<li><code>for-each</code></li>
<li><code>foldl</code></li>
</ul>
</div>
</div>

<div id="outline-container-orge00648f" class="outline-2">
<h2 id="orge00648f"><span class="section-number-2">2</span> Recursion on Lists</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org6e29c59" class="outline-3">
<h3 id="org6e29c59"><span class="section-number-3">2.1</span> Problem No. 1.1: Repeat</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The function <code>(repeat n x)</code> has to return a list containing
<code>n</code> copies of <code>x</code>. 
</p>
</div>

<div id="outline-container-org0c075bd" class="outline-4">
<h4 id="org0c075bd"><span class="section-number-4">2.1.1</span> Solution</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
We define a recursive function <code>repeat</code>:
</p>

<dl class="org-dl">
<dt>Base case (<code>n == 0</code>)</dt><dd>Returns an empty list</dd>
<dt>Recursive step</dt><dd>Append the value <code>x</code> to the list returned by recursively
calling the function with <code>n-1</code> and <code>x</code></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org50846d9">(define (repeat n x)
  (if (= n 0)
      '()
      (cons x (repeat (- n 1) x))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org27e5392" class="outline-3">
<h3 id="org27e5392"><span class="section-number-3">2.2</span> Problem No. 1.2: Invert</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The function <code>(invert lst)</code> has to be implemented, where:
</p>
<dl class="org-dl">
<dt><code>lst</code></dt><dd>A list of (lists of length 2)</dd>
<dt><code>invert</code></dt><dd>A function to invert each <code>lst</code></dd>
</dl>
</div>

<div id="outline-container-org5588fbc" class="outline-4">
<h4 id="org5588fbc"><span class="section-number-4">2.2.1</span> Solution:</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
We define a recursive function <code>invert</code>:
</p>

<dl class="org-dl">
<dt>Base case (<code>lst</code> is empty)</dt><dd>Returns an empty list</dd>
<dt>Recursive step</dt><dd><ol class="org-ol">
<li>Take the <code>(car lst)</code> and <code>(reverse)</code> it.</li>
<li>Append (cons) the result of step 1 to the value returned by recursively
calling the function with <code>(cdr lst)</code></li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="orgef5b3c9">(define (invert lst)
  (if (null? lst)
      '()
      (cons (reverse (car lst)) (invert (cdr lst)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgec3e1d5" class="outline-3">
<h3 id="orgec3e1d5"><span class="section-number-3">2.3</span> Problem No. 1.3: Count Occurences</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The function <code>(count-occurences s slist)</code> has to be implemented,
where it returns the number of occurences of <code>s</code> in <code>slist</code>
</p>
</div>

<div id="outline-container-org16c39fc" class="outline-4">
<h4 id="org16c39fc"><span class="section-number-4">2.3.1</span> Solution</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
We implement the function <code>(count-occurrences)</code> recursively. But first, we
setup a local function <code>(occplus s comp)</code> which will check for equality
between <code>s</code> and <code>comp</code> and return 1 if true, and 0 if false.
</p>

<p>
Then the recusion is defined as:
</p>

<dl class="org-dl">
<dt>Base case (<code>slist</code> is empty)</dt><dd>return 0</dd>
<dt>Recursive step</dt><dd>Sum the following:
<ol class="org-ol">
<li>1 if the <code>(car slist)</code> is equal to the comparison s,
using occplus, 0 otherwise</li>
<li>The result of a recursive call with <code>s</code> and <code>(cdr
                           slist)</code></li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org26e79bb">(define (count-occurrences s slist)
  (define (occplus s comp)
    (if (= s comp)
	1
	0))
  (if (null? slist)
      0
      (+ (occplus s (car slist)) (count-occurrences s (cdr slist)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0a3785f" class="outline-3">
<h3 id="org0a3785f"><span class="section-number-3">2.4</span> Problem No. 1.4: Product</h3>
<div class="outline-text-3" id="text-2-4">
<p>
We need to write a function <code>(product sos1 sos2)</code>, where:
</p>
<dl class="org-dl">
<dt><code>sos1</code>, <code>sos2</code></dt><dd>list of symbols without repetitions</dd>
<dt><code>product</code></dt><dd>function that will return the Cartesian product of the two
lists as a list of <code>2-lists</code></dd>
</dl>
</div>

<div id="outline-container-org970f629" class="outline-4">
<h4 id="org970f629"><span class="section-number-4">2.4.1</span> Solution</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
The idea is to recursively reduce <code>sos1</code> to a single-element list, and then
reduce <code>sos2</code> to a single element list, append the two, and then append that
to the returned value of the recursive call of <code>(cdr sos2)</code> and eventually
<code>(cdr sos1)</code>
</p>

<dl class="org-dl">
<dt>Base case(s)</dt><dd>There's two broad base cases:
<ul class="org-ul">
<li>If either <code>sos1</code> or <code>sos2</code> is empty, return the other.
This is as defined in the question. If neither list is
null to begin with, this case will not get triggered.</li>
<li>if both <code>sos1</code> and <code>sos2</code> are single-length, then return
a list appending the two</li>
</ul></dd>
<dt>Recursive step</dt><dd>Again, this is an if-else step:
<ul class="org-ul">
<li>If <code>sos1</code> is bigger than 1-element, append the result
of the recursive call with <code>(car sos1)</code> and the ones
with <code>(cdr sos1)</code></li>
<li>Likewise, but with <code>sos2</code></li>
</ul></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org51e35b7">(define (product sos1 sos2) 
  (cond
    [(null? sos1) sos2]
    [(null? sos2) sos1]
    [else 
      (cond
	[(&gt; (length sos1) 1)
	 (append (product (list (car sos1)) sos2) (product (cdr sos1) sos2))]
	[(&gt; (length sos2) 1)
	 (append (product sos1 (list (car sos2))) (product sos1 (cdr sos2)))]
	[else (list (append sos1 sos2))])]))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org90107ee" class="outline-3">
<h3 id="org90107ee"><span class="section-number-3">2.5</span> Problem No. 1.5: Every</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The function <code>(every pred lst)</code> needs to be implemented, where it takes a
list <code>lst</code> and does and <code>and</code> check against each element with the predicate
<code>pred</code>.
</p>
</div>

<div id="outline-container-org07325d8" class="outline-4">
<h4 id="org07325d8"><span class="section-number-4">2.5.1</span> Solution</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
We implement a recursive function, where 
</p>

<dl class="org-dl">
<dt>Base step (<code>lst</code> is empty)</dt><dd>returns true</dd>
<dt>Recursive step</dt><dd>return and <code>(and)</code> of the value of the <code>(pred)</code> on the
<code>(car lst)</code> and the value of the recursive call with <code>(cdr lst)</code></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org19d4e0c">(define (every pred lst) 
  (if (null? lst)
      #t
      (and (pred (car lst)) (every pred (cdr lst)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2dc6ec8" class="outline-3">
<h3 id="org2dc6ec8"><span class="section-number-3">2.6</span> Problem No. 1.6: Merge</h3>
<div class="outline-text-3" id="text-2-6">
<p>
The function <code>(merge loi1 loi2)</code> needs to take the two sorted lists <code>loi1</code>
and <code>loi2</code> and merge them such that the resulting list is also sorted.
</p>
</div>

<div id="outline-container-org947cf58" class="outline-4">
<h4 id="org947cf58"><span class="section-number-4">2.6.1</span> Solution</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
We define it recursively: if either list is empty, return the other,
otherwise compare the first elements of both and accordingly return the
appended element and the recursive call with the rest of the list and the
other list.
</p>

<dl class="org-dl">
<dt>Base cas (<code>loi1</code> or <code>loi2</code> is empty)</dt><dd>return the other list</dd>
<dt>Recursive step</dt><dd>Compare the <code>(car loi1)</code> with <code>(car loi2)</code>. The one
which is smaller will be appended to a new list along
with the result of the recursive function call with
<code>(cdr &lt;the list from which the smaller was taken&gt;)</code> and
<code>&lt;the other list&gt;</code></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="orgf7588e0">(define (merge loi1 loi2)
  (cond 
    [(null? loi1) loi2]
    [(null? loi2) loi1]
    [else 
      (if (&lt; (car loi1) (car loi2))
	     (append (list (car loi1)) (merge (cdr loi1) loi2))
	     (append (list (car loi2)) (merge loi1 (cdr loi2))))]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org56d7969" class="outline-3">
<h3 id="org56d7969"><span class="section-number-3">2.7</span> Flatten</h3>
<div class="outline-text-3" id="text-2-7">
<p>
The function <code>(flatten dlst)</code> needs to be implemented, and flatten
out any nested structure in the <code>dlst</code>. <code>dlst</code> is a list of lists in some
nested heirarchial structure.
</p>
</div>

<div id="outline-container-orgaa187a3" class="outline-4">
<h4 id="orgaa187a3"><span class="section-number-4">2.7.1</span> Solution</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
We make extensive use of the provided <code>(append list list)</code> function here.
After that, it's a rather straightforward recursive function.
</p>

<dl class="org-dl">
<dt>Base case(s)</dt><dd>There are two:
<ol class="org-ol">
<li>If <code>dlst</code> is empty, return an empty list</li>
<li>If <code>dlst</code> is not a list, return it as a list.</li>
</ol></dd>
<dt>Recursive step</dt><dd><code>(append)</code> the recursive calls with <code>(car dlst)</code> and
then <code>(cdr dlst)</code></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org8bf762e">(define (flatten dlst)
  (cond
    [(null? dlst) '()]
    [(not (list? dlst)) (list dlst)]
    [else (append (flatten (car dlst)) (flatten (cdr dlst)))]))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf0eb3bd" class="outline-2">
<h2 id="orgf0eb3bd"><span class="section-number-2">3</span> Recursion on Trees</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orge15887c" class="outline-3">
<h3 id="orge15887c"><span class="section-number-3">3.1</span> Problem No. 2.1: Preorder Traversal</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The function <code>(traverse/preorder tree)</code> needs to do a preorder traversal of
the given <code>tree</code>, aka return a list with <code>leaf left right</code> traversing.
</p>
</div>

<div id="outline-container-orgdcc5971" class="outline-4">
<h4 id="orgdcc5971"><span class="section-number-4">3.1.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
We use recursion along with <code>(cases)</code> in order to navigate the
custom-defined datatype <code>full-binary-tree</code>.
</p>

<dl class="org-dl">
<dt>Base case (<code>tree</code> is a leaf-node)</dt><dd>Return the value of the node</dd>
<dt>Recursive case</dt><dd>If <code>tree</code> is an internal node, return an <code>(append)</code> with
the:
<ol class="org-ol">
<li>Value of the node</li>
<li>The result of a recursive call with the left subtree</li>
<li>The result of a recursive call with the right subtree</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org9ecc5c6">(define (traverse/preorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
	(list v)
	(append 
	  (traverse/preorder left)
	  (traverse/preorder right))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2841796" class="outline-3">
<h3 id="org2841796"><span class="section-number-3">3.2</span> Problem No. 2.2: Inorder</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The function <code>(traverse/inorder tree)</code> needs to do a inorder traversal of
the given <code>tree</code>, aka return a list with <code>left leaf right</code> traversing.
</p>
</div>

<div id="outline-container-org1386721" class="outline-4">
<h4 id="org1386721"><span class="section-number-4">3.2.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
We use recursion along with <code>(cases)</code> in order to navigate the
custom-defined datatype <code>full-binary-tree</code>.
</p>

<dl class="org-dl">
<dt>Base case (<code>tree</code> is a leaf-node)</dt><dd>Return the value of the node</dd>
<dt>Recursive case</dt><dd>If <code>tree</code> is an internal node, return an <code>(append)</code> with
the:
<ol class="org-ol">
<li>The result of a recursive call with the left subtree</li>
<li>Value of the node</li>
<li>The result of a recursive call with the right subtree</li>
</ol></dd>
</dl>


<div class="org-src-container">
<pre class="src src-scheme" id="orgadaaad0">(define (traverse/inorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
	(traverse/inorder left) 
	(append 
	  (list v)
	  (traverse/inorder right))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9477419" class="outline-3">
<h3 id="org9477419"><span class="section-number-3">3.3</span> Problem No. 2.3: Postorder</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The function <code>(traverse/psotorder tree)</code> needs to do a postorder traversal of
the given <code>tree</code>, aka return a list with <code>left right leaf</code> traversing.
</p>
</div>

<div id="outline-container-orgc0fe089" class="outline-4">
<h4 id="orgc0fe089"><span class="section-number-4">3.3.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
We use recursion along with <code>(cases)</code> in order to navigate the
custom-defined datatype <code>full-binary-tree</code>.
</p>

<dl class="org-dl">
<dt>Base case (<code>tree</code> is a leaf-node)</dt><dd>Return the value of the node</dd>
<dt>Recursive case</dt><dd>If <code>tree</code> is an internal node, return an <code>(append)</code> with
the:
<ol class="org-ol">
<li>The result of a recursive call with the left subtree</li>
<li>The result of a recursive call with the right subtree</li>
<li>Value of the node</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="orgd400564">(define (traverse/postorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
	(traverse/postorder left) 
	(append 
	  (traverse/postorder right)
	  (list v))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8f50b82" class="outline-3">
<h3 id="org8f50b82"><span class="section-number-3">3.4</span> Problem No. 2.4: Count All Nodes</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Function <code>(count-nodes tree)</code> will count how many nodes are there.
</p>
</div>

<div id="outline-container-orgff1afc2" class="outline-4">
<h4 id="orgff1afc2"><span class="section-number-4">3.4.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
We use a recursive solution, to sum it up: for each node with a value, we
add 1 to the sum.
</p>

<dl class="org-dl">
<dt>Base case (tree is a leaf-node)</dt><dd>return 1</dd>
<dt>Recursive case (tree is an internal-node)</dt><dd>return the sum of 1 and the
recursive call with both
subtrees.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org6565d81">(define (count-nodes tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ 1 (count-nodes left) (count-nodes right)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3985fd4" class="outline-3">
<h3 id="org3985fd4"><span class="section-number-3">3.5</span> Problem No. 2.5: Count Leaf Nodes</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Function <code>(count-leaves tree)</code> will count how many leaf-nodes are there.
</p>
</div>

<div id="outline-container-org8d74b37" class="outline-4">
<h4 id="org8d74b37"><span class="section-number-4">3.5.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
We use a recursive solution, to sum it up: for each node that is a
leaf-node, we add 1 to the sum.
</p>

<dl class="org-dl">
<dt>Base case (tree is a leaf-node)</dt><dd>return 1</dd>
<dt>Recursive case (tree is an internal-node)</dt><dd>return the sum of the
recursive call with both
subtrees.</dd>
</dl>


<div class="org-src-container">
<pre class="src src-scheme" id="org90cef49">(define (count-leaves tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ (count-leaves left) (count-leaves right)))))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org102199e" class="outline-3">
<h3 id="org102199e"><span class="section-number-3">3.6</span> Problem No. 2.6: Count Internal Nodes</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Function <code>(count-internal tree)</code> will count how many internal-nodes are there
</p>
</div>

<div id="outline-container-orge94fbd5" class="outline-4">
<h4 id="orge94fbd5"><span class="section-number-4">3.6.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
We use a recursive solution, to sum it up: for each node that is an
internal-node, we add 1 to the sum.
</p>

<dl class="org-dl">
<dt>Base case (tree is a leaf-node)</dt><dd>return 0</dd>
<dt>Recursive case (tree is an internal-node)</dt><dd>return the sum of 1 and the
recursive call with both
subtrees.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="orgc3d4d90">(define (count-internal tree)
  (cases full-binary-tree tree
    (leaf-node (v) 0)
    (internal-node (v left right)
      (+ 1 (count-internal left) (count-internal right)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc1a76b2" class="outline-3">
<h3 id="orgc1a76b2"><span class="section-number-3">3.7</span> Problem No. 2.7: Map</h3>
<div class="outline-text-3" id="text-3-7">
<p>
The function <code>(tree/map fn tr)</code> needs to work like <code>(map)</code> but for trees.
</p>
</div>

<div id="outline-container-org6af120e" class="outline-4">
<h4 id="org6af120e"><span class="section-number-4">3.7.1</span> Solution:</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
We recursively navigate the tree such that:
</p>

<dl class="org-dl">
<dt>Base case (<code>tr</code> is a leaf-node)</dt><dd>return a new leaf-node with the
function <code>(fn)</code> applied to its value.</dd>
<dt>Recursive case (internal-node)</dt><dd>return a new internal-node with the 
<code>(fn)</code> applied to the value, and
recursive calls to the left and right
subtree as the left and right subtree
definitions.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org7be690b">(define (tree/map fn tr)
  (cases full-binary-tree tr
    (leaf-node (v) (lnode (fn v)))
    (internal-node (v left right)
      (inode (fn v) (tree/map fn left) (tree/map fn right)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf83f438" class="outline-3">
<h3 id="orgf83f438"><span class="section-number-3">3.8</span> Problem No. 2.8: Value at Path</h3>
<div class="outline-text-3" id="text-3-8">
<p>
Given a <code>path</code>, the function <code>(value-at-path path tree)</code> should navigate
through the <code>tree</code> and return the value of the node it reaches at the end of
the <code>path</code>.
</p>
</div>

<div id="outline-container-org78dd3c7" class="outline-4">
<h4 id="org78dd3c7"><span class="section-number-4">3.8.1</span> Solution</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
We navigate through the path as such: if the <code>path</code> is null, then we have 
found the solution. Here, we can return the value wrapped in a new node,
<code>(lnode v)</code> or <code>(inode v left right)</code> accordingly. Hoewever, if it is not,
then if the <code>(car)</code> is "left", we make a recursive call with the left 
subtree. However, if it's a leaf-node, we just return that as the search has
failed due to incorrect path. Likewise for if the <code>(car)</code> is "right" but
with the right subtree instead.
</p>

<dl class="org-dl">
<dt>Base case (<code>path</code> is empty)</dt><dd>Return the <code>tree</code>, which is the node at
the correct location</dd>
<dt>Recursive case</dt><dd>Depending on whether the <code>(car path)</code> is left or right,
<ol class="org-ol">
<li>If leaf node: this is a mistake, just return the node
as there's nothing else specified</li>
<li>If internal node: return the result of the recursive
call with the <code>(cdr path)</code> and the left/right
subtree.</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme" id="org6284d46">(define path-item (list "left" "right"))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme" id="orgdd8f261">(define (value-at-path path tree)
  (cond
    [(null? path) (cases full-binary-tree tree 
		    (leaf-node (v) v)
		    (internal-node (v left right) v))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) tree) ;; return the last node in the path
	(internal-node (v left right) (value-at-path (cdr path) left)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) tree) ;; return the last node in the path
	(internal-node (v left right) (value-at-path (cdr path) right)))]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1fd0791" class="outline-3">
<h3 id="org1fd0791"><span class="section-number-3">3.9</span> Problem No. 2.9: Search</h3>
<div class="outline-text-3" id="text-3-9">
<div class="org-src-container">
<pre class="src src-scheme" id="org1fb25f6">(define (search val tree)
  (cases full-binary-tree tree
    (leaf-node (v)
      (if (= v val)
	  '()
	  #f))
    (internal-node (v left right)
      (cond 
	[(= v val) '()]
	[(list? (search val left)) 
	    (append 
	      (list (list-ref path-item 0)) ;; very, and I cannot stress this
	      (search val left))] ;; enough, inefficient
	[(list? (search val right))
	    (append 
	      (list (list-ref path-item 1)) 
	      (search val right))]
	[else #f]))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga926a06" class="outline-3">
<h3 id="orga926a06"><span class="section-number-3">3.10</span> Problem No. 2.10: Update</h3>
<div class="outline-text-3" id="text-3-10">
<div class="org-src-container">
<pre class="src src-scheme" id="org8282f93">(define (update path fn tree)
  (cond
    [(null? path) 
      (cases full-binary-tree tree 
	(leaf-node (v) 
	  (lnode (fn v)))
	(internal-node (v left right) 
	  (inode (fn v) left right)))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v (update (cdr path) fn left) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v left (update (cdr path) fn right))))]))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd61e5c" class="outline-3">
<h3 id="orgbd61e5c"><span class="section-number-3">3.11</span> Problem No. 2.11: Insert</h3>
<div class="outline-text-3" id="text-3-11">
<div class="org-src-container">
<pre class="src src-scheme" id="org5a1a35a">(define (tree/insert path left-st right-st tree)
  (cond
    [(null? path)
      (cases full-binary-tree tree
	(leaf-node (v)
	  (inode v left-st right-st))
	(internal-node (v left right) ;; faulty pathfinding
	  (inode v left right)))] ;; return unchanged
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v (tree/insert (cdr path) left-st right-st tree) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v left (tree/insert (cdr path) left-st right-st tree))))]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5d9df27" class="outline-2">
<h2 id="org5d9df27"><span class="section-number-2">4</span> Tangle</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-scheme" id="org69cd107">#lang racket/base
(require eopl)
(require "datatypes.rkt")

(define (repeat n x)
  (if (= n 0)
      '()
      (cons x (repeat (- n 1) x))))
(define (invert lst)
  (if (null? lst)
      '()
      (cons (reverse (car lst)) (invert (cdr lst)))))
(define (count-occurrences s slist)
  (define (occplus s comp)
    (if (= s comp)
	1
	0))
  (if (null? slist)
      0
      (+ (occplus s (car slist)) (count-occurrences s (cdr slist)))))
(define (product sos1 sos2) 
  (cond
    [(null? sos1) sos2]
    [(null? sos2) sos1]
    [else 
      (cond
	[(&gt; (length sos1) 1)
	 (append (product (list (car sos1)) sos2) (product (cdr sos1) sos2))]
	[(&gt; (length sos2) 1)
	 (append (product sos1 (list (car sos2))) (product sos1 (cdr sos2)))]
	[else (list (append sos1 sos2))])]))
(define (every pred lst) 
  (if (null? lst)
      #t
      (and (pred (car lst)) (every pred (cdr lst)))))
(define (merge loi1 loi2)
  (cond 
    [(null? loi1) loi2]
    [(null? loi2) loi1]
    [else 
      (if (&lt; (car loi1) (car loi2))
	     (append (list (car loi1)) (merge (cdr loi1) loi2))
	     (append (list (car loi2)) (merge loi1 (cdr loi2))))]))
(define (flatten dlst)
  (cond
    [(null? dlst) '()]
    [(not (list? dlst)) (list dlst)]
    [else (append (flatten (car dlst)) (flatten (cdr dlst)))]))
(define (traverse/preorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
	(list v)
	(append 
	  (traverse/preorder left)
	  (traverse/preorder right))))))
(define (traverse/inorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
	(traverse/inorder left) 
	(append 
	  (list v)
	  (traverse/inorder right))))))
(define (traverse/postorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
	(traverse/postorder left) 
	(append 
	  (traverse/postorder right)
	  (list v))))))
(define (count-nodes tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ 1 (count-nodes left) (count-nodes right)))))
(define (count-leaves tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ (count-leaves left) (count-leaves right)))))
(define (count-internal tree)
  (cases full-binary-tree tree
    (leaf-node (v) 0)
    (internal-node (v left right)
      (+ 1 (count-internal left) (count-internal right)))))
(define (tree/map fn tr)
  (cases full-binary-tree tr
    (leaf-node (v) (lnode (fn v)))
    (internal-node (v left right)
      (inode (fn v) (tree/map fn left) (tree/map fn right)))))
(define path-item (list "left" "right"))
(define (value-at-path path tree)
  (cond
    [(null? path) (cases full-binary-tree tree 
		    (leaf-node (v) v)
		    (internal-node (v left right) v))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) tree) ;; return the last node in the path
	(internal-node (v left right) (value-at-path (cdr path) left)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) tree) ;; return the last node in the path
	(internal-node (v left right) (value-at-path (cdr path) right)))]))
(define (search val tree)
  (cases full-binary-tree tree
    (leaf-node (v)
      (if (= v val)
	  '()
	  #f))
    (internal-node (v left right)
      (cond 
	[(= v val) '()]
	[(list? (search val left)) 
	    (append 
	      (list (list-ref path-item 0)) ;; very, and I cannot stress this
	      (search val left))] ;; enough, inefficient
	[(list? (search val right))
	    (append 
	      (list (list-ref path-item 1)) 
	      (search val right))]
	[else #f]))))
(define (update path fn tree)
  (cond
    [(null? path) 
      (cases full-binary-tree tree 
	(leaf-node (v) 
	  (lnode (fn v)))
	(internal-node (v left right) 
	  (inode (fn v) left right)))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v (update (cdr path) fn left) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v left (update (cdr path) fn right))))]))
(define (tree/insert path left-st right-st tree)
  (cond
    [(null? path)
      (cases full-binary-tree tree
	(leaf-node (v)
	  (inode v left-st right-st))
	(internal-node (v left right) ;; faulty pathfinding
	  (inode v left right)))] ;; return unchanged
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v (tree/insert (cdr path) left-st right-st tree) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
	(leaf-node (v) (lnode v)) ;; return unchanged
	(internal-node (v left right)
	  (inode v left (tree/insert (cdr path) left-st right-st tree))))]))

;;; exporting only the required function
(provide repeat)
(provide invert)
(provide count-occurrences)
(provide product)
(provide every)
(provide merge)
(provide flatten)
(provide traverse/preorder)
(provide traverse/inorder)
(provide traverse/postorder)
(provide count-nodes)
(provide count-leaves)
(provide count-internal)
(provide tree/map)
(provide value-at-path)
(provide search)
(provide update)
(provide tree/insert)
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zubair Abid (20171076)</p>
<p class="date">Created: 2020-08-17 Mon 17:48</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
