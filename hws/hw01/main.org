#+NAME: Homework Assignment 01 : Solution
#+AUTHOR: Zubair Abid (20171076)

* Introduction

  Solution to HW01 of PoPL Monsoon 2020.

  All of the solutions have been implemented using recursion and avoid using 
  any of the following inbuilt functions:

  - =map=
  - =andmap=
  - =ormap=
  - =for-each=
  - =foldl=

* Recursion on Lists

** Problem No. 1.1: Repeat
   The function =(repeat n x)= has to return a list containing
   =n= copies of =x=. 

*** Solution
   We define a recursive function =repeat=:
   
   - Base case (~n == 0~) ::  Returns an empty list
   - Recursive step :: Append the value =x= to the list returned by recursively
     calling the function with =n-1= and =x=
   
#+NAME: repeat
#+BEGIN_SRC scheme
(define (repeat n x)
  (if (= n 0)
      '()
      (cons x (repeat (- n 1) x))))
#+END_SRC

** Problem No. 1.2: Invert
   The function =(invert lst)= has to be implemented, where:
   - =lst= :: A list of (lists of length 2)
   - =invert= :: A function to invert each =lst=

*** Solution:
    We define a recursive function =invert=:

    - Base case (=lst= is empty) :: Returns an empty list
    - Recursive step ::
      1. Take the =(car lst)= and =(reverse)= it.
      2. Append (cons) the result of step 1 to the value returned by recursively
         calling the function with =(cdr lst)=
   
#+NAME: invert
#+BEGIN_SRC scheme
(define (invert lst)
  (if (null? lst)
      '()
      (cons (reverse (car lst)) (invert (cdr lst)))))
#+END_SRC

** Problem No. 1.3: Count Occurences
   The function =(count-occurences s slist)= has to be implemented,
   where it returns the number of occurences of =s= in =slist=

*** Solution
    We implement the function =(count-occurrences)= recursively. But first, we
    setup a local function =(occplus s comp)= which will check for equality
    between =s= and =comp= and return 1 if true, and 0 if false.

    Then the recusion is defined as:

    - Base case (=slist= is empty) :: return 0
    - Recursive step :: Sum the following:
                        1. 1 if the =(car slist)= is equal to the comparison s,
                           using occplus, 0 otherwise
                        2. The result of a recursive call with =s= and =(cdr
                           slist)=
   
#+NAME: count-occurrences
#+BEGIN_SRC scheme
(define (count-occurrences s slist)
  (define (occplus s comp)
    (if (= s comp)
        1
        0))
  (if (null? slist)
      0
      (+ (occplus s (car slist)) (count-occurrences s (cdr slist)))))
#+END_SRC

** Problem No. 1.4: Product
   We need to write a function =(product sos1 sos2)=, where:
   - =sos1=, =sos2= :: list of symbols without repetitions
   - =product= :: function that will return the Cartesian product of the two
                  lists as a list of =2-lists=

*** Solution
    The idea is to recursively reduce =sos1= to a single-element list, and then
    reduce =sos2= to a single element list, append the two, and then append that
    to the returned value of the recursive call of =(cdr sos2)= and eventually
    =(cdr sos1)=

    - Base case(s) :: There's two broad base cases:
                     - If either =sos1= or =sos2= is empty, return the other.
                       This is as defined in the question. If neither list is
                       null to begin with, this case will not get triggered.
                     - if both =sos1= and =sos2= are single-length, then return
                       a list appending the two
    - Recursive step :: Again, this is an if-else step:
                        - If =sos1= is bigger than 1-element, append the result
                          of the recursive call with =(car sos1)= and the ones
                          with =(cdr sos1)=
                        - Likewise, but with =sos2=

#+NAME: product
#+BEGIN_SRC scheme
(define (product sos1 sos2) 
  (cond
    [(null? sos1) sos2]
    [(null? sos2) sos1]
    [else 
      (cond
        [(> (length sos1) 1)
         (append (product (list (car sos1)) sos2) (product (cdr sos1) sos2))]
        [(> (length sos2) 1)
         (append (product sos1 (list (car sos2))) (product sos1 (cdr sos2)))]
        [else (list (append sos1 sos2))])]))
#+END_SRC
** Problem No. 1.5: Every
   The function =(every pred lst)= needs to be implemented, where it takes a
   list =lst= and does and =and= check against each element with the predicate
   =pred=.

*** Solution
    We implement a recursive function, where 

    - Base step (=lst= is empty) :: returns true
    - Recursive step :: return and =(and)= of the value of the =(pred)= on the
      =(car lst)= and the value of the recursive call with =(cdr lst)=

#+NAME: every
#+BEGIN_SRC scheme
(define (every pred lst) 
  (if (null? lst)
      #t
      (and (pred (car lst)) (every pred (cdr lst)))))
#+END_SRC
** Problem No. 1.6: Merge
   The function =(merge loi1 loi2)= needs to take the two sorted lists =loi1=
   and =loi2= and merge them such that the resulting list is also sorted.

*** Solution
    We define it recursively: if either list is empty, return the other,
    otherwise compare the first elements of both and accordingly return the
    appended element and the recursive call with the rest of the list and the
    other list.

    - Base cas (=loi1= or =loi2= is empty) :: return the other list
    - Recursive step :: Compare the =(car loi1)= with =(car loi2)=. The one
                        which is smaller will be appended to a new list along
                        with the result of the recursive function call with
                        =(cdr <the list from which the smaller was taken>)= and
                        =<the other list>=

#+NAME: merge
#+BEGIN_SRC scheme
(define (merge loi1 loi2)
  (cond 
    [(null? loi1) loi2]
    [(null? loi2) loi1]
    [else 
      (if (< (car loi1) (car loi2))
             (append (list (car loi1)) (merge (cdr loi1) loi2))
             (append (list (car loi2)) (merge loi1 (cdr loi2))))]))
#+END_SRC

** Flatten
   The function =(flatten dlst)= needs to be implemented, and flatten
   out any nested structure in the =dlst=. =dlst= is a list of lists in some
   nested heirarchial structure.

*** Solution
    We make extensive use of the provided =(append list list)= function here.
    After that, it's a rather straightforward recursive function.

    - Base case(s) :: There are two:
                      1. If =dlst= is empty, return an empty list
                      2. If =dlst= is not a list, return it as a list.
    - Recursive step :: =(append)= the recursive calls with =(car dlst)= and
                        then =(cdr dlst)=

#+NAME: flatten
#+BEGIN_SRC scheme
(define (flatten dlst)
  (cond
    [(null? dlst) '()]
    [(not (list? dlst)) (list dlst)]
    [else (append (flatten (car dlst)) (flatten (cdr dlst)))]))
#+END_SRC

* Recursion on Trees

** Problem No. 2.1: Preorder Traversal
   The function =(traverse/preorder tree)= needs to do a preorder traversal of
   the given =tree=, aka return a list with =leaf left right= traversing.

*** Solution
    We use recursion along with =(cases)= in order to navigate the
    custom-defined datatype =full-binary-tree=.

    - Base case (=tree= is a leaf-node) :: Return the value of the node
    - Recursive case :: If =tree= is an internal node, return an =(append)= with
                        the:
                        1. Value of the node
                        2. The result of a recursive call with the left subtree
                        3. The result of a recursive call with the right subtree

#+NAME: traverse/preorder
#+BEGIN_SRC scheme
(define (traverse/preorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
        (list v)
        (append 
          (traverse/preorder left)
          (traverse/preorder right))))))
#+END_SRC

** Problem No. 2.2: Inorder
   The function =(traverse/inorder tree)= needs to do a inorder traversal of
   the given =tree=, aka return a list with =left leaf right= traversing.

*** Solution
    We use recursion along with =(cases)= in order to navigate the
    custom-defined datatype =full-binary-tree=.

    - Base case (=tree= is a leaf-node) :: Return the value of the node
    - Recursive case :: If =tree= is an internal node, return an =(append)= with
                        the:
                        1. The result of a recursive call with the left subtree
                        2. Value of the node
                        3. The result of a recursive call with the right subtree


#+NAME: traverse/inorder
#+BEGIN_SRC scheme
(define (traverse/inorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
        (traverse/inorder left) 
        (append 
          (list v)
          (traverse/inorder right))))))
#+END_SRC

** Problem No. 2.3: Postorder
   The function =(traverse/psotorder tree)= needs to do a postorder traversal of
   the given =tree=, aka return a list with =left right leaf= traversing.

*** Solution
    We use recursion along with =(cases)= in order to navigate the
    custom-defined datatype =full-binary-tree=.

    - Base case (=tree= is a leaf-node) :: Return the value of the node
    - Recursive case :: If =tree= is an internal node, return an =(append)= with
                        the:
                        1. The result of a recursive call with the left subtree
                        2. The result of a recursive call with the right subtree
                        3. Value of the node

#+NAME: traverse/postorder
#+BEGIN_SRC scheme
(define (traverse/postorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
        (traverse/postorder left) 
        (append 
          (traverse/postorder right)
          (list v))))))
#+END_SRC

** Problem No. 2.4: Count All Nodes
   Function =(count-nodes tree)= will count how many nodes are there.

*** Solution
    We use a recursive solution, to sum it up: for each node with a value, we
    add 1 to the sum.

    - Base case (tree is a leaf-node) :: return 1
    - Recursive case (tree is an internal-node) :: return the sum of 1 and the
                                                   recursive call with both
                                                   subtrees.

#+NAME: count-nodes
#+BEGIN_SRC scheme
(define (count-nodes tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ 1 (count-nodes left) (count-nodes right)))))
#+END_SRC

** Problem No. 2.5: Count Leaf Nodes
   Function =(count-leaves tree)= will count how many leaf-nodes are there.

*** Solution
    We use a recursive solution, to sum it up: for each node that is a
    leaf-node, we add 1 to the sum.

    - Base case (tree is a leaf-node) :: return 1
    - Recursive case (tree is an internal-node) :: return the sum of the
                                                   recursive call with both
                                                   subtrees.


#+NAME: count-leaves
#+BEGIN_SRC scheme
(define (count-leaves tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ (count-leaves left) (count-leaves right)))))
#+END_SRC


** Problem No. 2.6: Count Internal Nodes
   Function =(count-internal tree)= will count how many internal-nodes are there

*** Solution
    We use a recursive solution, to sum it up: for each node that is an
    internal-node, we add 1 to the sum.

    - Base case (tree is a leaf-node) :: return 0
    - Recursive case (tree is an internal-node) :: return the sum of 1 and the
                                                   recursive call with both
                                                   subtrees.

#+NAME: count-internal
#+BEGIN_SRC scheme
(define (count-internal tree)
  (cases full-binary-tree tree
    (leaf-node (v) 0)
    (internal-node (v left right)
      (+ 1 (count-internal left) (count-internal right)))))
#+END_SRC

** Problem No. 2.7: Map
   The function =(tree/map fn tr)= needs to work like =(map)= but for trees.

*** Solution:
    We recursively navigate the tree such that:

    - Base case (=tr= is a leaf-node) :: return a new leaf-node with the
                                         function =(fn)= applied to its value.
    - Recursive case (internal-node) :: return a new internal-node with the 
                                        =(fn)= applied to the value, and
                                        recursive calls to the left and right
                                        subtree as the left and right subtree
                                        definitions.

#+NAME: tree/map
#+BEGIN_SRC scheme
(define (tree/map fn tr)
  (cases full-binary-tree tr
    (leaf-node (v) (lnode (fn v)))
    (internal-node (v left right)
      (inode (fn v) (tree/map fn left) (tree/map fn right)))))
#+END_SRC

** Problem No. 2.8: Value at Path

   
#+NAME: path-item
#+BEGIN_SRC scheme 
(define path-item (list "left" "right"))
#+END_SRC
   
#+NAME: value-at-path
#+BEGIN_SRC scheme
(define (value-at-path path tree)
  (cond
    [(null? path) (cases full-binary-tree tree 
                    (leaf-node (v) v)
                    (internal-node (v left right) v))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) tree) ;; return the last node in the path
        (internal-node (v left right) (value-at-path (cdr path) left)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) tree) ;; return the last node in the path
        (internal-node (v left right) (value-at-path (cdr path) right)))]))
#+END_SRC

** Problem No. 2.9: Search


#+NAME: search
#+BEGIN_SRC scheme
(define (search val tree)
  (cases full-binary-tree tree
    (leaf-node (v)
      (if (= v val)
          '()
          #f))
    (internal-node (v left right)
      (cond 
        [(= v val) '()]
        [(list? (search val left)) 
            (append 
              (list (list-ref path-item 0)) ;; very, and I cannot stress this
              (search val left))] ;; enough, inefficient
        [(list? (search val right))
            (append 
              (list (list-ref path-item 1)) 
              (search val right))]
        [else #f]))))
#+END_SRC

** Problem No. 2.10: Update

#+NAME: update
#+BEGIN_SRC scheme
(define (update path fn tree)
  (cond
    [(null? path) 
      (cases full-binary-tree tree 
        (leaf-node (v) 
          (lnode (fn v)))
        (internal-node (v left right) 
          (inode (fn v) left right)))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v (update (cdr path) fn left) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v left (update (cdr path) fn right))))]))
#+END_SRC
  
** Problem No. 2.11: Insert

#+NAME: tree/insert
#+BEGIN_SRC scheme
(define (tree/insert path left-st right-st tree)
  (cond
    [(null? path)
      (cases full-binary-tree tree
        (leaf-node (v)
          (inode v left-st right-st))
        (internal-node (v left right) ;; faulty pathfinding
          (inode v left right)))] ;; return unchanged
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v (tree/insert (cdr path) left-st right-st tree) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v left (tree/insert (cdr path) left-st right-st tree))))]))
#+END_SRC

* Tangle

#+NAME: solution
#+BEGIN_SRC scheme :noweb yes :tangle ./main.rkt
#lang racket/base
(require eopl)
(require "datatypes.rkt")

<<repeat>>
<<invert>>
<<count-occurrences>>
<<product>>
<<every>>
<<merge>>
<<flatten>>
<<traverse/preorder>>
<<traverse/inorder>>
<<traverse/postorder>>
<<count-nodes>>
<<count-leaves>>
<<count-internal>>
<<tree/map>>
<<path-item>>
<<value-at-path>>
<<search>>
<<update>>
<<tree/insert>>

;;; exporting only the required function
(provide repeat)
(provide invert)
(provide count-occurrences)
(provide product)
(provide every)
(provide merge)
(provide flatten)
(provide traverse/preorder)
(provide traverse/inorder)
(provide traverse/postorder)
(provide count-nodes)
(provide count-leaves)
(provide count-internal)
(provide tree/map)
(provide value-at-path)
(provide search)
(provide update)
(provide tree/insert)
#+END_SRC
