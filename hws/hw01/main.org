#+NAME: Homework Assignment 01 : Solution

* Recursion on Lists

** Problem No. 1.1: Repeat
   The function =(repeat n x)= has to return a list containing
   =n= copies of =x=. 

*** Solution
   We define a recursive function =repeat=:
   
   - Base case (~n == 0~) ::  Returns an empty list
   - Recursive step :: Append the value =x= 
   to the list returned by recursively calling 
   the function with =n-1= and =x= 
   
#+NAME: repeat
#+BEGIN_SRC scheme
(define (repeat n x)
  (if (= n 0)
      '()
      (cons x (repeat (- n 1) x))))
#+END_SRC

** Problem No. 1.2: Invert
   The function =(invert lst)= has to be implemented, where:
   - =lst= :: A list of (lists of length 2)
   - =invert= :: A function to invert each =lst=

*** Solution:
    We define a recursive function =invert=:

    - Base case (~null? lst~) :: Returns an empty list
    - Recursive step ::
      1. Take the =(car lst)= and =(reverse)= it.
      2. Append the result of step 1 to the value returned by
         recursively calling the function with =(cdr lst)=
   
#+NAME: invert
#+BEGIN_SRC scheme
(define (invert lst)
  (if (null? lst)
      '()
      (cons (reverse (car lst)) (invert (cdr lst)))))
#+END_SRC

** Problem No. 1.3: Count Occurences
   The function =(count-occurences s slist)= has to be implemented,
   where it returns the number of occurences of =s= in =slist=
   
#+NAME: count-occurrences
#+BEGIN_SRC scheme
(define (count-occurrences s slist)
  (define (occplus s comp)
    (if (= s comp)
        1
        0))
  (if (null? slist)
      0
      (+ (occplus s (car slist)) (count-occurrences s (cdr slist)))))
#+END_SRC

** Problem No. 1.4: Product
   ndkjsnskjdnfkjdsf

#+NAME: product
#+BEGIN_SRC scheme
(define (product sos1 sos2) 
  (cond
    [(null? sos1) sos2]
    [(null? sos2) sos1]
    [else (cond
            [(> (length sos1) 1)
             (append (product (list (car sos1)) sos2) (product (cdr sos1) sos2))]
            [(> (length sos2) 1)
             (append (product sos1 (list (car sos2))) (product sos1 (cdr sos2)))]
            [else (list (append sos1 sos2))])]))
#+END_SRC
** Problem No. 1.1: Every

** Problem No. 1.2: Merge

* Recursion on Trees

** Problem No. 2.1: Preorder Traversal

** Problem No. 2.2: Inorder

** Problem No. 2.3: Postorder

** Problem No. 2.4: Count All Nodes

** Problem No. 2.5: Count Leaf Nodes

** Problem No. 2.6: Count Internal Nodes

** Problem No. 2.7: Map

** Problem No. 2.8: Value at Path

** Problem No. 2.9: Search

** Problem No. 2.10: Update

** Problem No. 2.11: Insert
* Tangle

#+NAME: solution
#+BEGIN_SRC scheme :noweb yes :tangle ./main.rkt
#lang racket/base

<<repeat>>
<<invert>>
<<count-occurrences>>
<<product>>

;;; exporting only the required function
(provide repeat)
(provide invert)
(provide count-occurrences)
(provide product)
#+END_SRC
