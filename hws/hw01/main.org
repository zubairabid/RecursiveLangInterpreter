#+NAME: Homework Assignment 01 : Solution
#+AUTHOR: Zubair Abid (20171076)

* Introduction

  Solution to HW01 of PoPL Monsoon 2020.

  All of the solutions have been implemented using recursion and avoid using 
  any of the following inbuilt functions:

  - =map=
  - =andmap=
  - =ormap=
  - =for-each=
  - =foldl=

* Recursion on Lists

** Problem No. 1.1: Repeat
   The function =(repeat n x)= has to return a list containing
   =n= copies of =x=. 

*** Solution
   We define a recursive function =repeat=:
   
   - Base case (~n == 0~) ::  Returns an empty list
   - Recursive step :: Append the value =x= to the list returned by recursively
     calling the function with =n-1= and =x=
   
#+NAME: repeat
#+BEGIN_SRC scheme
(define (repeat n x)
  (if (= n 0)
      '()
      (cons x (repeat (- n 1) x))))
#+END_SRC

** Problem No. 1.2: Invert
   The function =(invert lst)= has to be implemented, where:
   - =lst= :: A list of (lists of length 2)
   - =invert= :: A function to invert each =lst=

*** Solution:
    We define a recursive function =invert=:

    - Base case (=lst= is empty) :: Returns an empty list
    - Recursive step ::
      1. Take the =(car lst)= and =(reverse)= it.
      2. Append (cons) the result of step 1 to the value returned by recursively
         calling the function with =(cdr lst)=
   
#+NAME: invert
#+BEGIN_SRC scheme
(define (invert lst)
  (if (null? lst)
      '()
      (cons (reverse (car lst)) (invert (cdr lst)))))
#+END_SRC

** Problem No. 1.3: Count Occurences
   The function =(count-occurences s slist)= has to be implemented,
   where it returns the number of occurences of =s= in =slist=

*** Solution
    We implement the function =(count-occurrences)= recursively. But first, we
    setup a local function =(occplus s comp)= which will check for equality
    between =s= and =comp= and return 1 if true, and 0 if false.

    Then the recusion is defined as:

    - Base case (=slist= is empty) :: return 0
    - Recursive step :: Sum the following:
                        1. 1 if the =(car slist)= is equal to the comparison s,
                           using occplus, 0 otherwise
                        2. The result of a recursive call with =s= and =(cdr
                           slist)=
   
#+NAME: count-occurrences
#+BEGIN_SRC scheme
(define (count-occurrences s slist)
  (define (occplus s comp)
    (if (= s comp)
        1
        0))
  (if (null? slist)
      0
      (+ (occplus s (car slist)) (count-occurrences s (cdr slist)))))
#+END_SRC

** Problem No. 1.4: Product
   We need to write a function =(product sos1 sos2)=, where:
   - =sos1=, =sos2= :: list of symbols without repetitions
   - =product= :: function that will return the Cartesian product of the two
                  lists as a list of =2-lists=

*** Solution
    The idea is to recursively reduce =sos1= to a single-element list, and then
    reduce =sos2= to a single element list, append the two, and then append that
    to the returned value of the recursive call of =(cdr sos2)= and eventually
    =(cdr sos1)=

#+NAME: product
#+BEGIN_SRC scheme
(define (product sos1 sos2) 
  (cond
    [(null? sos1) sos2]
    [(null? sos2) sos1]
    [else 
      (cond
        [(> (length sos1) 1)
         (append (product (list (car sos1)) sos2) (product (cdr sos1) sos2))]
        [(> (length sos2) 1)
         (append (product sos1 (list (car sos2))) (product sos1 (cdr sos2)))]
        [else (list (append sos1 sos2))])]))
#+END_SRC
** Problem No. 1.5: Every

#+NAME: every
#+BEGIN_SRC scheme
(define (every pred lst) 
  (if (null? lst)
      #t
      (and (pred (car lst)) (every pred (cdr lst)))))
#+END_SRC
** Problem No. 1.6: Merge


#+NAME: merge
#+BEGIN_SRC scheme
(define (merge loi1 loi2)
  (cond 
    [(null? loi1) loi2]
    [(null? loi2) loi1]
    [else 
      (if (< (car loi1) (car loi2))
             (append (list (car loi1)) (merge (cdr loi1) loi2))
             (append (list (car loi2)) (merge loi1 (cdr loi2))))]))
#+END_SRC

** Flatten

#+NAME: flatten
#+BEGIN_SRC scheme
(define (flatten dlst)
  (cond
    [(null? dlst) '()]
    [(not (list? dlst)) (list dlst)]
    [else (append (flatten (car dlst)) (flatten (cdr dlst)))]))
#+END_SRC

* Recursion on Trees

** Problem No. 2.1: Preorder Traversal

#+NAME: traverse/preorder
#+BEGIN_SRC scheme
(define (traverse/preorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
        (list v)
        (append 
          (traverse/preorder left)
          (traverse/preorder right))))))
#+END_SRC

** Problem No. 2.2: Inorder

#+NAME: traverse/inorder
#+BEGIN_SRC scheme
(define (traverse/inorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
        (traverse/inorder left) 
        (append 
          (list v)
          (traverse/inorder right))))))
#+END_SRC

** Problem No. 2.3: Postorder

#+NAME: traverse/postorder
#+BEGIN_SRC scheme
(define (traverse/postorder tree)
  (cases full-binary-tree tree
    (leaf-node (v) (list v))
    (internal-node (v left right) 
      (append 
        (traverse/postorder left) 
        (append 
          (traverse/postorder right)
          (list v))))))
#+END_SRC

** Problem No. 2.4: Count All Nodes

#+NAME: count-nodes
#+BEGIN_SRC scheme
(define (count-nodes tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ 1 (count-nodes left) (count-nodes right)))))
#+END_SRC

** Problem No. 2.5: Count Leaf Nodes


#+NAME: count-leaves
#+BEGIN_SRC scheme
(define (count-leaves tree)
  (cases full-binary-tree tree
    (leaf-node (v) 1)
    (internal-node (v left right)
      (+ (count-leaves left) (count-leaves right)))))
#+END_SRC


** Problem No. 2.6: Count Internal Nodes

#+NAME: count-internal
#+BEGIN_SRC scheme
(define (count-internal tree)
  (cases full-binary-tree tree
    (leaf-node (v) 0)
    (internal-node (v left right)
      (+ 1 (count-internal left) (count-internal right)))))
#+END_SRC

** Problem No. 2.7: Map

#+NAME: tree/map
#+BEGIN_SRC scheme
(define (tree/map fn tr)
  (cases full-binary-tree tr
    (leaf-node (v) (lnode (fn v)))
    (internal-node (v left right)
      (inode (fn v) (tree/map fn left) (tree/map fn right)))))
#+END_SRC

** Problem No. 2.8: Value at Path

   
#+NAME: path-item
#+BEGIN_SRC scheme 
(define path-item (list "left" "right"))
#+END_SRC
   
#+NAME: value-at-path
#+BEGIN_SRC scheme
(define (value-at-path path tree)
  (cond
    [(null? path) (cases full-binary-tree tree 
                    (leaf-node (v) v)
                    (internal-node (v left right) v))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) tree) ;; return the last node in the path
        (internal-node (v left right) (value-at-path (cdr path) left)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) tree) ;; return the last node in the path
        (internal-node (v left right) (value-at-path (cdr path) right)))]))
#+END_SRC

** Problem No. 2.9: Search


#+NAME: search
#+BEGIN_SRC scheme
(define (search val tree)
  (cases full-binary-tree tree
    (leaf-node (v)
      (if (= v val)
          '()
          #f))
    (internal-node (v left right)
      (cond 
        [(= v val) '()]
        [(list? (search val left)) 
            (append 
              (list (list-ref path-item 0)) ;; very, and I cannot stress this
              (search val left))] ;; enough, inefficient
        [(list? (search val right))
            (append 
              (list (list-ref path-item 1)) 
              (search val right))]
        [else #f]))))
#+END_SRC

** Problem No. 2.10: Update

#+NAME: update
#+BEGIN_SRC scheme
(define (update path fn tree)
  (cond
    [(null? path) 
      (cases full-binary-tree tree 
        (leaf-node (v) 
          (lnode (fn v)))
        (internal-node (v left right) 
          (inode (fn v) left right)))]
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v (update (cdr path) fn left) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v left (update (cdr path) fn right))))]))
#+END_SRC
  
** Problem No. 2.11: Insert

#+NAME: tree/insert
#+BEGIN_SRC scheme
(define (tree/insert path left-st right-st tree)
  (cond
    [(null? path)
      (cases full-binary-tree tree
        (leaf-node (v)
          (inode v left-st right-st))
        (internal-node (v left right) ;; faulty pathfinding
          (inode v left right)))] ;; return unchanged
    [(equal? (list-ref path-item 0) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v (tree/insert (cdr path) left-st right-st tree) right)))]
    [(equal? (list-ref path-item 1) (car path))
      (cases full-binary-tree tree
        (leaf-node (v) (lnode v)) ;; return unchanged
        (internal-node (v left right)
          (inode v left (tree/insert (cdr path) left-st right-st tree))))]))
#+END_SRC

* Tangle

#+NAME: solution
#+BEGIN_SRC scheme :noweb yes :tangle ./main.rkt
#lang racket/base
(require eopl)
(require "datatypes.rkt")

<<repeat>>
<<invert>>
<<count-occurrences>>
<<product>>
<<every>>
<<merge>>
<<flatten>>
<<traverse/preorder>>
<<traverse/inorder>>
<<traverse/postorder>>
<<count-nodes>>
<<count-leaves>>
<<count-internal>>
<<tree/map>>
<<path-item>>
<<value-at-path>>
<<search>>
<<update>>
<<tree/insert>>

;;; exporting only the required function
(provide repeat)
(provide invert)
(provide count-occurrences)
(provide product)
(provide every)
(provide merge)
(provide flatten)
(provide traverse/preorder)
(provide traverse/inorder)
(provide traverse/postorder)
(provide count-nodes)
(provide count-leaves)
(provide count-internal)
(provide tree/map)
(provide value-at-path)
(provide search)
(provide update)
(provide tree/insert)
#+END_SRC
